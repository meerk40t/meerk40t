#!/usr/bin/env python
#
# generated by wxGlade 0.9.3 on Mon Dec 30 01:30:50 2019
#

import math

import wx

from meerk40t.core.units import Length
from meerk40t.gui.choicepropertypanel import ChoicePropertyPanel
from meerk40t.gui.icons import icon_rotary
from meerk40t.gui.mwindow import MWindow
from meerk40t.gui.wxutils import (
    ScrolledPanel,
    StaticBoxSizer,
    TextCtrl,
    dip_size,
    wxButton,
    wxCheckBox,
    wxStaticText,
)
from meerk40t.kernel import signal_listener
from meerk40t.tools.geomstr import Geomstr

_ = wx.GetTranslation


class HelperPanelChuck(ScrolledPanel):
    def __init__(self, *args, context=None, node=None, **kwds):
        kwds["style"] = kwds.get("style", 0)
        wx.Panel.__init__(self, *args, **kwds)
        self.job_active = False
        self.context = context
        self.startstop = {
            "balor": (self.stop_balor_display, self.start_balor_display),
            "galvo": (self.stop_balor_display, self.start_balor_display),
        }
        self.test_buttons = []
        for angle in (-360, -180, -90, 0, 90, 180, 360):
            self.test_buttons.append(
                wxButton(self, wx.ID_ANY, f"{angle}°", size=(50, -1))
            )
            self.test_buttons[-1].SetToolTip(
                _("Rotate to {angle}°").format(angle=angle)
            )
            self.Bind(wx.EVT_BUTTON, self.on_rotate(angle, True), self.test_buttons[-1])
            self.test_buttons[-1].Bind(
                wx.EVT_RIGHT_DOWN,
                self.on_rotate(angle, False),
            )
        self.txt_position = TextCtrl(self, wx.ID_ANY, "", limited=True)
        self.txt_position.Enable(False)
        self.btn_plus = wxButton(self, wx.ID_ANY, "+")
        self.btn_plus.SetToolTip(_("Shift to right by 1mm / by 10mm on right click"))
        self.btn_minus = wxButton(self, wx.ID_ANY, "-")
        self.btn_minus.SetToolTip(_("Shift to left by 1mm / by 10mm on right click"))
        self.check_show = wxCheckBox(self, wx.ID_ANY, _("Show"))
        self.check_show.SetToolTip(
            _("Show the current position of the rotary axis in the preview.")
        )
        self.text_extension = TextCtrl(
            self,
            wx.ID_ANY,
            "4cm",
            check="length",
            limited=True,
            style=wx.TE_PROCESS_ENTER,
        )
        self.check_magnets = wxCheckBox(self, wx.ID_ANY, _("Set magnets"))
        self.check_magnets.SetToolTip(
            _("Set magnets at the corners of the rectangle and at the center axis")
        )
        self.check_magnets.SetValue(True)

        self.btn_create_rectangle = wxButton(self, wx.ID_ANY, _("Create"))
        self.btn_create_rectangle.SetToolTip(
            _("Create a helper rectangle for design & alignment")
        )

        self.__do_layout()
        self.__do_logic()

    def __do_layout(self):
        for ctrl in (
            self.txt_position,
            self.text_extension,
        ):
            ctrl.SetMinSize(dip_size(self, 80, -1))
        self.btn_minus.SetMinSize(dip_size(self, 30, -1))
        self.btn_plus.SetMinSize(dip_size(self, 30, -1))
        self.sizer = StaticBoxSizer(self, wx.ID_ANY, _("Setup Helper"), wx.VERTICAL)
        sizer_buttons = StaticBoxSizer(
            self, wx.ID_ANY, _("Test rotation..."), wx.HORIZONTAL
        )
        for button in self.test_buttons:
            sizer_buttons.Add(button, 0, wx.EXPAND, 0)
        self.sizer.Add(sizer_buttons, 0, wx.EXPAND, 0)
        sizer_offset = StaticBoxSizer(
            self, wx.ID_ANY, _("Rotary position"), wx.HORIZONTAL
        )
        sizer_offset.Add(self.txt_position, 0, 0, 0)
        sizer_offset.Add(self.btn_minus, 0, 0, 0)
        sizer_offset.Add(self.btn_plus, 0, 0, 0)
        sizer_offset.AddSpacer(10)
        sizer_offset.Add(self.check_show, 0, 0, 0)
        self.sizer.Add(sizer_offset, 0, wx.EXPAND, 0)
        sizer_test = StaticBoxSizer(
            self, wx.ID_ANY, _("Create alignment rectangle"), wx.VERTICAL
        )

        sizer_extension = wx.BoxSizer(wx.HORIZONTAL)
        label_extension = wxStaticText(self, wx.ID_ANY, _("Secondary extension:"))
        sizer_extension.Add(label_extension, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_extension.Add(self.text_extension, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_test.Add(sizer_extension, 0, wx.EXPAND, 0)
        sizer_test.Add(self.check_magnets, 0, wx.EXPAND, 0)
        sizer_test.Add(self.btn_create_rectangle, 0, wx.EXPAND, 0)
        self.sizer.Add(sizer_test, 0, wx.EXPAND, 0)
        self.SetSizer(self.sizer)

    def __do_logic(self):
        self.Bind(wx.EVT_BUTTON, self.on_position(+1), self.btn_plus)
        self.btn_plus.Bind(wx.EVT_RIGHT_DOWN, self.on_position(+10))
        self.Bind(wx.EVT_BUTTON, self.on_position(-1), self.btn_minus)
        self.btn_minus.Bind(wx.EVT_RIGHT_DOWN, self.on_position(-10))
        self.Bind(wx.EVT_CHECKBOX, self.on_check_show, self.check_show)
        self.btn_create_rectangle.Enable(False)
        self.Bind(wx.EVT_TEXT, self.on_rectangle_input, self.text_extension)
        self.Bind(wx.EVT_BUTTON, self.on_create_rectangle, self.btn_create_rectangle)
        # self.Bind(wx.EVT_RADIOBOX, self.on_radio_roller, self.radio_roller)

    def pane_show(self):
        # Nothing to be done here, as the values are set in the rotary settings panel
        service = self.context.device
        zero_pos = Length(
            f"{service.rotary.rotary_chuck_offset * 100}%",
            relative_length=service.view.width
            if service.rotary.rotary_chuck_alignment_axis == 0
            else service.view.height,
            digits=3,
        )
        self.txt_position.SetValue(zero_pos.length_mm)
        if self.job_active:
            self.start_display()

    def pane_hide(self):
        # Nothing to be done here, as the values are set in the rotary settings panel
        self.stop_display()

    def on_position(self, offset):
        def handler(event):
            if self.context.device.rotary.rotary_chuck_offset is None:
                return
            current_offset = self.context.device.rotary.rotary_chuck_offset
            min_val = 0
            max_val = float(
                self.context.device.view.width
                if self.context.device.rotary.rotary_chuck_alignment_axis == 0
                else self.context.device.view.height
            )
            l_offset = Length(f"{current_offset * 100}%", relative_length=max_val)
            l_offset += Length(f"{offset}mm")
            newval = max(float(l_offset), min_val)
            newval = min(newval, max_val)
            self.context.device.rotary.rotary_chuck_offset = newval / max_val
            self.context.signal("rotary_chuck_offset", newval)
            self.txt_position.SetValue(Length(newval, digits=3).length_mm)
            self.context.signal("refresh_scene", "Scene")
            if self.job_active:
                self.start_display()
                # Update Live Lightjob / Laserhead position

        return handler

    def on_check_show(self, event=None):
        self.stop_display()
        if self.check_show.IsChecked():
            self.start_display()

    def on_rotate(self, angle, absolute):
        def handler(event):
            relstr = "" if absolute else "-r "
            self.context(f"rotary rotate -f {relstr}{angle}deg\n")

        return handler

    def on_rectangle_input(self, event=None):
        flag = False
        if self.text_extension.GetValue() != "":
            try:
                ext1 = float(Length(self.text_extension.GetValue()))
                ext2 = (
                    float(Length(self.context.device.rotary.object_diameter)) * math.pi
                )
                if ext1 > 0 and ext2 > 0:
                    flag = True
            except ValueError:
                flag = False
        self.btn_create_rectangle.Enable(flag)

    def on_create_rectangle(self, event=None):
        try:
            maxval = (
                self.context.device.view.width
                if self.context.device.rotary.rotary_chuck_alignment_axis == 0
                else self.context.device.view.height
            )
            pos = float(
                Length(
                    f"{self.context.device.rotary.rotary_chuck_offset * 100}%",
                    relative_length=maxval,
                )
            )
            # print (f"Position: {self.context.device.rotary.rotary_roller_offset * 100}% of {maxval} = {pos}")
            secondary_ext = float(Length(self.text_extension.GetValue()))
            primary_ext = float(
                Length(self.context.device.rotary.object_diameter) * math.pi
            )
        except ValueError:
            wx.MessageBox(
                _("Invalid position or extension value."),
                _("Error"),
                wx.OK | wx.ICON_ERROR,
            )
            return

        obj_extent = primary_ext

        if self.context.device.rotary.rotary_chuck_alignment_axis == 0:
            # X-axis is the roller
            x1 = pos - obj_extent / 2
            x2 = pos + obj_extent / 2
            y1 = 0
            y2 = secondary_ext
            center_axis = "x"
        else:
            # Y-axis is the roller
            x1 = 0
            x2 = secondary_ext
            y1 = pos - obj_extent / 2
            y2 = pos + obj_extent / 2
            center_axis = "y"

        self.context(
            f'rect {x1} {y1} {x2 - x1} {y2 - y1} label "Rotation Alignment Rectangle"\n'
        )
        if self.check_magnets.GetValue():
            self.context(f"magnet clear x\n")
            self.context(f"magnet clear y\n")
            self.context(f"magnet set x {x1}\n")
            self.context(f"magnet set x {x2}\n")
            self.context(f"magnet set y {y1}\n")
            self.context(f"magnet set y {y2}\n")
            self.context(f"magnet set {center_axis} {pos}\n")

    def stop_generic(self):
        # Nothing to be done here
        return

    def start_generic(self):
        # We move the laserhead to the new position
        if self.context.device.rotary.rotary_chuck_alignment_axis == 0:
            newval = (
                self.context.device.rotary.rotary_chuck_offset
                * self.context.device.view.width
            )
            self.context.device.move_abs(newval, 0)
        else:
            newval = (
                self.context.device.rotary.rotary_chuck_offset
                * self.context.device.view.height
            )
            self.context.device.move_abs(0, newval)

    def stop_balor_display(self):
        if self.job:
            self.job.stop()
            self.job = None

    def start_balor_display(self):
        from meerk40t.balormk.livelightjob import LiveLightJob

        geom = Geomstr()
        if self.context.device.rotary.rotary_chuck_alignment_axis == 0:
            # show perpendicular line
            newval = (
                self.context.device.rotary.rotary_chuck_offset
                * self.context.device.view.unit_width
            )
            geom.line(
                complex(newval, 0),
                complex(newval, self.context.device.view.unit_height),
            )
        else:
            newval = (
                self.context.device.rotary.rotary_chuck_offset
                * self.context.device.view.unit_height
            )
            geom.line(
                complex(0, newval), complex(self.context.device.view.unit_width, newval)
            )

        self.job_active = True
        self.job = LiveLightJob(
            self.context.device,
            "geometry",
            geometry=geom,
            travel_speed=8000,
            jump_delay=10,
            plain=True,
        )
        self.context.device.spooler.send(self.job)

    def stop_display(self):
        if self.job_active:
            self.job_active = False
            devname = self.context.device.name.lower()
            if devname in self.startstop:
                routine = self.startstop[devname][0]
            else:
                routine = self.stop_generic
            routine()

    def start_display(self):
        if self.job_active:
            self.stop_display()

        self.job_active = True
        devname = self.context.device.name.lower()
        if devname in self.startstop:
            if devname in self.startstop:
                routine = self.startstop[devname][1]
            else:
                routine = self.start_generic
            routine()


class HelperPanelRoller(ScrolledPanel):
    def __init__(self, *args, context=None, node=None, **kwds):
        kwds["style"] = kwds.get("style", 0)
        wx.Panel.__init__(self, *args, **kwds)
        self.context = context
        # self.radio_roller = wxRadioBox(
        #     self, wx.ID_ANY, _("Rotation-Axis"), choices=["X", "Y"], majorDimension=0
        # )
        # self.radio_roller.SetToolTip(_("Select the rotation axis of the roller"))
        self.txt_position = TextCtrl(self, wx.ID_ANY, "", limited=True)
        self.txt_position.Enable(False)
        self.btn_plus = wxButton(self, wx.ID_ANY, "+")
        self.btn_plus.SetToolTip(_("Shift to right by 1mm / by 10mm on right click"))
        self.btn_minus = wxButton(self, wx.ID_ANY, "-")
        self.btn_minus.SetToolTip(_("Shift to left by 1mm / by 10mm on right click"))

        self.text_rotary_roller_diameter = TextCtrl(
            self,
            wx.ID_ANY,
            "50.0mm",
            check="length",
            limited=True,
            style=wx.TE_PROCESS_ENTER,
        )
        self.text_rotary_object_diameter = TextCtrl(
            self,
            wx.ID_ANY,
            "50.0mm",
            check="length",
            limited=True,
            style=wx.TE_PROCESS_ENTER,
        )
        self.text_rotary_roller_diameter.SetToolTip(_("Diameter of the rotary roller"))
        self.text_rotary_object_diameter.SetToolTip(
            _("Diameter of the object to be rotated")
        )

        self.btn_calculate = wxButton(self, wx.ID_ANY, _("Calculate"))
        self.btn_calculate.SetToolTip(_("Calculate the scale for the rotary roller"))

        self.text_extension = TextCtrl(
            self,
            wx.ID_ANY,
            "4cm",
            check="length",
            limited=True,
            style=wx.TE_PROCESS_ENTER,
        )
        self.check_magnets = wxCheckBox(self, wx.ID_ANY, _("Set magnets"))
        self.check_magnets.SetToolTip(
            _("Set magnets at the corners of the rectangle and at the center axis")
        )
        self.check_magnets.SetValue(True)

        self.btn_create_rectangle = wxButton(self, wx.ID_ANY, _("Create"))
        self.btn_create_rectangle.SetToolTip(
            _("Create a helper rectangle for design & alignment")
        )
        self.__do_layout()
        self.__do_logic()

    def __do_layout(self):
        for ctrl in (
            self.txt_position,
            self.text_extension,
            self.text_rotary_roller_diameter,
            self.text_rotary_object_diameter,
        ):
            ctrl.SetMinSize(dip_size(self, 80, -1))
        self.sizer = StaticBoxSizer(self, wx.ID_ANY, _("Setup Helper"), wx.VERTICAL)
        sizer_calculate = StaticBoxSizer(self, wx.ID_ANY, _("Calculate"), wx.VERTICAL)
        sizer_input = StaticBoxSizer(self, wx.ID_ANY, _("Circumferences"), wx.VERTICAL)
        sizer_input1 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_input2 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_offset = StaticBoxSizer(
            self, wx.ID_ANY, _("Rotary position"), wx.HORIZONTAL
        )
        sizer_offset.Add(self.txt_position, 0, 0, 0)
        sizer_offset.Add(self.btn_minus, 0, 0, 0)
        sizer_offset.Add(self.btn_plus, 0, 0, 0)

        # sizer_calculate.Add(self.radio_roller, 0, wx.EXPAND, 0)
        sizer_calculate.Add(sizer_offset, 0, wx.EXPAND, 0)
        label_mm1 = wxStaticText(self, wx.ID_ANY, _("Roller:"))
        sizer_input1.Add(label_mm1, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_input1.Add(self.text_rotary_roller_diameter, 1, wx.EXPAND, 0)

        label_mm2 = wxStaticText(self, wx.ID_ANY, _("Object:"))
        sizer_input2.Add(label_mm2, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_input2.Add(self.text_rotary_object_diameter, 1, wx.EXPAND, 0)
        sizer_input.Add(sizer_input1, 0, 0, 0)
        sizer_input.Add(sizer_input2, 0, 0, 0)
        sizer_calculate.Add(sizer_input, 0, 0, 0)
        sizer_calculate.Add(self.btn_calculate, 0, 0, 0)
        label_info = wxStaticText(
            self,
            wx.ID_ANY,
            _(
                "Notabene: the resulting factor is valid for all objects on the roller,\nand needs only to be established once."
            ),
        )
        sizer_calculate.Add(label_info, 0, wx.EXPAND, 0)

        self.sizer.Add(sizer_calculate, 0, wx.EXPAND, 0)
        sizer_test = StaticBoxSizer(
            self, wx.ID_ANY, _("Create alignment rectangle"), wx.VERTICAL
        )

        sizer_extension = wx.BoxSizer(wx.HORIZONTAL)
        label_extension = wxStaticText(self, wx.ID_ANY, _("Secondary extension:"))
        sizer_extension.Add(label_extension, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_extension.Add(self.text_extension, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_test.Add(sizer_extension, 0, wx.EXPAND, 0)
        sizer_test.Add(self.check_magnets, 0, wx.EXPAND, 0)
        sizer_test.Add(self.btn_create_rectangle, 0, wx.EXPAND, 0)
        self.sizer.Add(sizer_test, 0, wx.EXPAND, 0)
        self.context.themes.set_window_colors(self)
        self.SetHelpText("rotaryroller_helper")
        self.SetSizer(self.sizer)
        self.Layout()
        self.SetupScrolling()

    def __do_logic(self):
        # self.Bind(wx.EVT_TEXT, self.on_text_rotary_roller_circumference, self.text_rotary_roller_circumference)
        # self.Bind(wx.EVT_TEXT, self.on_text_rotary_object_circumference, self.text_rotary_object_circumference)
        for ctrl in (
            self.txt_position,
            self.text_extension,
            self.text_rotary_object_diameter,
        ):
            ctrl.Bind(wx.EVT_TEXT, self.on_rectangle_input)
        for ctrl in (
            self.text_rotary_roller_diameter,
            self.text_rotary_object_diameter,
        ):
            ctrl.SetActionRoutine(self.on_calculate)
        # is_x = self.context.device.rotary.rotary_roller_alignment_axis == 1.0
        # self.radio_roller.SetSelection(0 if is_x else 1)
        self.btn_create_rectangle.Enable(False)
        self.Bind(wx.EVT_BUTTON, self.on_calculate, self.btn_calculate)
        self.Bind(wx.EVT_BUTTON, self.on_create_rectangle, self.btn_create_rectangle)
        # self.Bind(wx.EVT_RADIOBOX, self.on_radio_roller, self.radio_roller)
        self.Bind(wx.EVT_BUTTON, self.on_position(+1), self.btn_plus)
        self.btn_plus.Bind(wx.EVT_RIGHT_DOWN, self.on_position(+10))
        self.Bind(wx.EVT_BUTTON, self.on_position(-1), self.btn_minus)
        self.btn_minus.Bind(wx.EVT_RIGHT_DOWN, self.on_position(-10))

    def pane_show(self):
        # Nothing to be done here, as the values are set in the rotary settings panel
        service = self.context.device
        zero_pos = Length(
            f"{service.rotary.rotary_roller_offset * 100}%",
            relative_length=service.view.width
            if service.rotary.rotary_roller_alignment_axis == 0
            else service.view.height,
            digits=3,
        )
        self.txt_position.SetValue(zero_pos.length_mm)

    def pane_hide(self):
        # Nothing to be done here, as the values are set in the rotary settings panel
        return

    def on_position(self, offset):
        def handler(event):
            if self.context.device.rotary.rotary_roller_offset is None:
                return
            current_offset = self.context.device.rotary.rotary_roller_offset
            min_val = 0
            max_val = float(
                self.context.device.view.width
                if self.context.device.rotary.rotary_roller_alignment_axis == 0
                else self.context.device.view.height
            )
            l_offset = Length(f"{current_offset * 100}%", relative_length=max_val)
            l_offset += Length(f"{offset}mm")
            newval = max(float(l_offset), min_val)
            newval = min(newval, max_val)
            self.context.device.rotary.rotary_roller_offset = newval / max_val
            self.context.signal("rotary_roller_offset", newval / max_val)
            self.txt_position.SetValue(Length(newval, digits=3).length_mm)
            self.context.signal("refresh_scene", "Scene")

        return handler

    def on_rectangle_input(self, event=None):
        flag = False
        if self.text_extension.GetValue() != "":
            try:
                ext1 = float(Length(self.text_extension.GetValue()))
                ext2 = (
                    float(Length(self.text_rotary_object_diameter.GetValue())) * math.pi
                )
                if ext1 > 0 and ext2 > 0:
                    flag = True
            except ValueError:
                flag = False
        self.btn_create_rectangle.Enable(flag)

    def on_create_rectangle(self, event=None):
        try:
            maxval = (
                self.context.device.view.width
                if self.context.device.rotary.rotary_roller_alignment_axis == 0
                else self.context.device.view.height
            )
            pos = float(
                Length(
                    f"{self.context.device.rotary.rotary_roller_offset * 100}%",
                    relative_length=maxval,
                )
            )
            # print (f"Position: {self.context.device.rotary.rotary_roller_offset * 100}% of {maxval} = {pos}")
            secondary_ext = float(Length(self.text_extension.GetValue()))
            primary_ext = float(
                Length(self.text_rotary_object_diameter.GetValue()) * math.pi
            )
        except ValueError:
            wx.MessageBox(
                _("Invalid position or extension value."),
                _("Error"),
                wx.OK | wx.ICON_ERROR,
            )
            return

        obj_extent = primary_ext

        if self.context.device.rotary.rotary_roller_alignment_axis == 0:
            # X-axis is the roller
            x1 = pos - obj_extent / 2
            x2 = pos + obj_extent / 2
            y1 = 0
            y2 = secondary_ext
            center_axis = "x"
        else:
            # Y-axis is the roller
            x1 = 0
            x2 = secondary_ext
            y1 = pos - obj_extent / 2
            y2 = pos + obj_extent / 2
            center_axis = "y"

        self.context(
            f'rect {x1} {y1} {x2 - x1} {y2 - y1} label "Rotation Alignment Rectangle"\n'
        )
        if self.check_magnets.GetValue():
            self.context(f"magnet clear x\n")
            self.context(f"magnet clear y\n")
            self.context(f"magnet set x {x1}\n")
            self.context(f"magnet set x {x2}\n")
            self.context(f"magnet set y {y1}\n")
            self.context(f"magnet set y {y2}\n")
            self.context(f"magnet set {center_axis} {pos}\n")

    def on_calculate(self, event=None):
        roller_diameter = self.text_rotary_roller_diameter.GetValue()
        object_diameter = self.text_rotary_object_diameter.GetValue()
        if not roller_diameter or not object_diameter:
            return
        try:
            l_roller = float(Length(roller_diameter))
            l_object = float(Length(object_diameter))
        except ValueError:
            return
        if l_roller <= 0 or l_object <= 0:
            wx.MessageBox(
                _("Diameter values must be greater than 0."),
                _("Error"),
                wx.OK | wx.ICON_ERROR,
            )
            return
        factor = l_object / l_roller
        if self.context.device.rotary.rotary_roller_alignment_axis == 0:
            self.context.device.rotary.rotary_roller_scale_x = factor
            self.context.device.rotary.rotary_roller_scale_y = 1.0
        else:
            self.context.device.rotary.rotary_roller_scale_x = 1.0
            self.context.device.rotary.rotary_roller_scale_y = factor
        # print(
        #     f"Roller factor: {factor} -> {self.context.device.rotary.rotary_roller_scale_x}, {self.context.device.rotary.rotary_roller_scale_y}"
        # )
        self.context.signal(
            "rotary_roller_scale_x", self.context.device.rotary.rotary_roller_scale_x
        )
        self.context.signal(
            "rotary_roller_scale_y", self.context.device.rotary.rotary_roller_scale_y
        )

    # def on_radio_roller(self, event=None):
    #     getsel = self.radio_roller.GetSelection()
    #     sx = self.context.device.rotary.rotary_roller_scale_x
    #     sy = self.context.device.rotary.rotary_roller_scale_y
    #     factor = sx if sx != 1.0 else sy
    #     if getsel == 0:
    #         self.context.device.rotary.rotary_roller_scale_y = 1.0
    #         self.context.device.rotary.rotary_roller_scale_x = factor
    #     else:
    #         self.context.device.rotary.rotary_roller_scale_y = factor
    #         self.context.device.rotary.rotary_roller_scale_x = 1.0
    #     self.context.device.rotary.rotary_roller_alignment_axis = 0 if getsel == 0 else 1
    #     self.context.signal(
    #         "rotary_roller_scale_x", self.context.device.rotary.rotary_roller_scale_x
    #     )
    #     self.context.signal(
    #         "rotary_roller_scale_y", self.context.device.rotary.rotary_roller_scale_y
    #     )
    #     self.context.signal(
    #         "rotary_roller_alignment_axis", self.context.device.rotary.rotary_roller_alignment_axis
    #     )


class RotarySettings(MWindow):
    def __init__(self, *args, **kwds):
        super().__init__(350, 250, *args, **kwds)
        self.panels = []
        self.has_roller = getattr(self.context.device, "supports_rotary_roller", False)
        self.has_chuck = getattr(self.context.device, "supports_rotary_chuck", False)

        if self.has_roller:
            self.roller_panel = ChoicePropertyPanel(
                self, wx.ID_ANY, context=self.context.device, choices="rotary_roller"
            )
            self.helper_panel_roller = HelperPanelRoller(
                self, wx.ID_ANY, context=self.context
            )
            self.sizer_roller = wx.BoxSizer(wx.HORIZONTAL)
            self.sizer_roller.Add(self.roller_panel, 1, wx.EXPAND, 0)
            self.sizer_roller.Add(self.helper_panel_roller, 1, wx.EXPAND, 0)
            self.sizer.Add(self.sizer_roller, 2, wx.EXPAND, 0)
            self.panels.extend((self.roller_panel, self.helper_panel_roller))
        if self.has_chuck:
            self.chuck_panel = ChoicePropertyPanel(
                self, wx.ID_ANY, context=self.context.device, choices="rotary_chuck"
            )
            self.helper_panel_chuck = HelperPanelChuck(
                self, wx.ID_ANY, context=self.context
            )
            self.sizer_chuck = wx.BoxSizer(wx.HORIZONTAL)
            self.sizer_chuck.Add(self.chuck_panel, 1, wx.EXPAND, 0)
            self.sizer_chuck.Add(self.helper_panel_chuck, 1, wx.EXPAND, 0)

            self.sizer.Add(self.sizer_chuck, 2, wx.EXPAND, 0)
            self.panels.extend((self.chuck_panel, self.helper_panel_chuck))
        if self.has_roller or self.has_chuck:
            self.common_panel = ChoicePropertyPanel(
                self, wx.ID_ANY, context=self.context.device, choices="rotary_common"
            )
            self.sizer.Add(self.common_panel, 1, wx.EXPAND, 0)
            self.panels.append(self.common_panel)
        for panel in self.panels:
            self.add_module_delegate(panel)
        _icon = wx.NullIcon
        _icon.CopyFromBitmap(icon_rotary.GetBitmap())
        self.SetIcon(_icon)
        self.SetTitle(_("Rotary-Settings"))
        self.restore_aspect(honor_initial_values=True)

    def window_open(self):
        for panel in self.panels:
            panel.pane_show()

    def window_close(self):
        for panel in self.panels:
            panel.pane_hide()

    @staticmethod
    def submenu():
        return "Device-Settings", "Rotary-Settings"

    @staticmethod
    def helptext():
        return _("Activate and configure rotary")

    @signal_listener("rotary_roller_scale_x")
    @signal_listener("rotary_roller_scale_y")
    @signal_listener("rotary_roller_flip_x")
    @signal_listener("rotary_roller_flip_y")
    @signal_listener("rotary_active_chuck")
    @signal_listener("rotary_active_roller")
    @signal_listener("rotary_chuck_offset")
    @signal_listener("rotary_chuck_alignment_axis")
    @signal_listener("rotary_roller_offset")
    @signal_listener("rotary_roller_alignment_axis")
    def signal_rotary(self, *args, **kwargs):
        if self.has_roller:
            self.roller_panel.reload()
            self.helper_panel_roller.pane_show()
        if self.has_chuck:
            self.chuck_panel.reload()
            self.helper_panel_chuck.pane_show()
