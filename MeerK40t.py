# -*- coding: ISO-8859-1 -*-
#
# generated by wxGlade 0.9.3 on Thu Jun 27 21:45:40 2019
#

import sys
import traceback

import wx
import wx.ribbon as RB

from Alignment import Alignment
from BufferView import BufferView
from ColorDefine import ColorDefine
from Controller import Controller
from DefaultModules import *
from ElementProperty import ElementProperty
from JobInfo import JobInfo
from JobSpooler import JobSpooler
from K40Controller import K40Controller
from Kernel import *
from Keymap import Keymap
from LaserRender import LaserRender, swizzlecolor
from LhymicroWriter import LhymicroWriter
from Navigation import Navigation
from Preferences import Preferences
from RotarySettings import RotarySettings
from UsbConnect import UsbConnect
from ZMatrix import ZMatrix
from icons import *
from svgelements import *

try:
    from math import tau
except ImportError:
    from math import pi

    tau = pi * 2

"""
Laser software for the Stock-LIHUIYU laserboard.

MeerK40t (pronounced MeerKat) is a built-from-the-ground-up MIT licensed 
open-source laser cutting software. See https://github.com/meerk40t/meerk40t
for full details.

"""

MILS_IN_MM = 39.3701
MEERK40T_VERSION = "0.3.2"
MEERK40T_ISSUES = "https://github.com/meerk40t/meerk40t/issues"
MEERK40T_WEBSITE = "https://github.com/meerk40t/meerk40t"


# begin wxGlade: dependencies
# end wxGlade

class IdInc:
    """
    Id Incrementor
    """

    def __init__(self):
        self.id_highest_value = wx.ID_HIGHEST

    def new(self):
        self.id_highest_value += 1
        return self.id_highest_value


idinc = IdInc()
ID_MAIN_TOOLBAR = idinc.new()
ID_ADD_FILE = idinc.new()
ID_OPEN = idinc.new()
ID_SAVE = idinc.new()
ID_NAV = idinc.new()
ID_USB = idinc.new()
ID_CONTROLLER = idinc.new()
ID_PREFERENCES = idinc.new()
ID_JOB = idinc.new()
ID_SPOOLER = idinc.new()

ID_CUT_CONFIGURATION = idinc.new()
ID_SELECT = idinc.new()

ID_MENU_NEW = idinc.new()
ID_MENU_OPEN_PROJECT = idinc.new()
ID_MENU_RECENT_PROJECT = idinc.new()

ID_MENU_IMPORT = idinc.new()
ID_MENU_SAVE = idinc.new()
ID_MENU_SAVE_AS = idinc.new()
ID_MENU_EXIT = idinc.new()
ID_MENU_ZOOM_OUT = idinc.new()
ID_MENU_ZOOM_IN = idinc.new()
ID_MENU_ZOOM_SIZE = idinc.new()

# 1 fill, 2 grids, 4 guides, 8 laserpath, 16 writer_position, 32 selection
ID_MENU_HIDE_FILLS = idinc.new()
ID_MENU_HIDE_GUIDES = idinc.new()
ID_MENU_HIDE_GRID = idinc.new()
ID_MENU_HIDE_STROKES = idinc.new()
ID_MENU_HIDE_LASERPATH = idinc.new()
ID_MENU_HIDE_RETICLE = idinc.new()
ID_MENU_HIDE_SELECTION = idinc.new()
ID_MENU_SCREEN_REFRESH = idinc.new()
ID_MENU_SCREEN_ANIMATE = idinc.new()
ID_MENU_HIDE_IMAGE = idinc.new()
ID_MENU_HIDE_PATH = idinc.new()
ID_MENU_HIDE_TEXT = idinc.new()

ID_MENU_ALIGNMENT = idinc.new()
ID_MENU_KEYMAP = idinc.new()
ID_MENU_COLORDEFINE = idinc.new()
ID_MENU_PREFERENCES = idinc.new()
ID_MENU_ROTARY = idinc.new()
ID_MENU_NAVIGATION = idinc.new()
ID_MENU_CONTROLLER = idinc.new()
ID_MENU_USB = idinc.new()
ID_MENU_SPOOLER = idinc.new()
ID_MENU_JOB = idinc.new()
ID_MENU_TREE = idinc.new()

ID_MENU_WEBPAGE = idinc.new()
ID_CUT_TREE = idinc.new()
ID_CUT_BURN_BUTTON = idinc.new()

_ = wx.GetTranslation
project = Kernel()
project.run_later = wx.CallAfter
project.translation = wx.GetTranslation
project.set_config(wx.Config("MeerK40t"))
project.add_module('K40Controller', K40Controller())
project.add_module('K40Writer', LhymicroWriter())
project.add_module('SVGLoader', SVGLoader())
project.add_module('ImageLoader', ImageLoader())
project.add_module('EgvLoader', EgvLoader())
project.add_module('SVGWriter', SVGWriter())

project.add_window('ElementProperty', ElementProperty)
project.add_window('Controller', Controller)
project.add_window("Preferences", Preferences)
project.add_window("Rotary", RotarySettings)
project.add_window("Alignment", Alignment)
project.add_window("Keymap", Keymap)
project.add_window("ColorDefine", ColorDefine)
project.add_window("UsbConnect", UsbConnect)
project.add_window("Navigation", Navigation)
project.add_window("Controller", Controller)
project.add_window("JobSpooler", JobSpooler)
project.add_window("JobInfo", JobInfo)
project.add_window("BufferView", BufferView)
project.boot()

supported_languages = (('en', u'English', wx.LANGUAGE_ENGLISH),
                       ('fr', u'français', wx.LANGUAGE_FRENCH),
                       ('de', u'Deutsch', wx.LANGUAGE_GERMAN),
                       ('es', u'español', wx.LANGUAGE_SPANISH))


class MeerK40t(wx.Frame):
    """
    MeerK40t main window
    """

    def __init__(self, *args, **kwds):
        # begin wxGlade: MeerK40t.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.project = project
        project.setting(int, "draw_mode", 0)  # 1 fill, 2 grids, 4 guides, 8 laserpath, 16 writer_position, 32 selection
        project.setting(int, "window_width", 1200)
        project.setting(int, "window_height", 600)
        project.setting(int, "bed_width", 320)
        project.setting(int, "bed_height", 220)
        project.setting(float, "units_convert", 39.37)
        project.setting(str, "units_name", 'mm')
        project.setting(int, "units_marks", 10)
        project.setting(int, "units_index", 0)
        project.setting(bool, "mouse_zoom_invert", False)
        project.setting(int, 'fps', 40)
        if project.fps <= 0:
            project.fps = 60
        project.setting(int, 'language', None)

        if project.window_width < 300:
            project.window_width = 300
        if project.window_height < 300:
            project.window_height = 300

        project.add_control("Path", self.open_path_dialog)
        project.add_control("FPS", self.open_fps_dialog)

        self.locale = None
        wx.Locale.AddCatalogLookupPathPrefix('locale')
        language = project.language
        if language is not None and language != 0:
            self.language_to(language)(None)

        self.SetSize((project.window_width, project.window_height))
        self.DragAcceptFiles(True)

        self.tree = wx.TreeCtrl(self, wx.ID_ANY, style=wx.TR_MULTIPLE)  # wx.FULL_REPAINT_ON_RESIZE |
        self.tree_images = wx.ImageList()
        self.tree_images.Create(width=20, height=20)
        self.tree.SetImageList(self.tree_images)
        self.scene = wx.Panel(self, style=wx.EXPAND | wx.WANTS_CHARS)
        self.scene.SetDoubleBuffered(True)

        self._ribbon = RB.RibbonBar(self, style=RB.RIBBON_BAR_DEFAULT_STYLE
                                                | RB.RIBBON_BAR_SHOW_PANEL_EXT_BUTTONS)

        home = RB.RibbonPage(self._ribbon, wx.ID_ANY, _("Examples"), icons8_opened_folder_50.GetBitmap())
        toolbar_panel = RB.RibbonPanel(home, wx.ID_ANY, _("Toolbar"),
                                       style=RB.RIBBON_PANEL_NO_AUTO_MINIMISE | RB.RIBBON_PANEL_EXT_BUTTON)

        toolbar = RB.RibbonToolBar(toolbar_panel, ID_MAIN_TOOLBAR)
        self.toolbar = toolbar

        toolbar.AddTool(ID_OPEN, icons8_opened_folder_50.GetBitmap(), "")  # "Open",
        toolbar.AddTool(ID_SAVE, icons8_save_50.GetBitmap(), "")
        toolbar.AddTool(ID_JOB, icons8_laser_beam_52.GetBitmap(), "")

        windows_panel = RB.RibbonPanel(home, wx.ID_ANY, _("Windows"), icons8_opened_folder_50.GetBitmap())
        windows = RB.RibbonButtonBar(windows_panel)
        windows.AddButton(ID_NAV, _("Navigation"), icons8_move_32.GetBitmap(), "")
        windows.AddButton(ID_USB, _("Usb"), icons8_usb_connector_50.GetBitmap(), "")
        windows.AddButton(ID_SPOOLER, _("Spooler"), icons8_route_50.GetBitmap(), "")
        windows.AddButton(ID_CONTROLLER, _("Controller"), icons8_connected_50.GetBitmap(), "")
        windows.AddButton(ID_PREFERENCES, _("Preferences"), icons8_administrative_tools_50.GetBitmap(), "")
        self._ribbon.Realize()

        self.CenterOnScreen()
        # Menu Bar
        self.main_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_MENU_NEW, _("New"), "")
        wxglade_tmp_menu.Append(ID_MENU_OPEN_PROJECT, _("Open Project"), "")
        wxglade_tmp_menu.Append(ID_MENU_IMPORT, _("Import File"), "")
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_MENU_SAVE, _("Save"), "")
        wxglade_tmp_menu.Append(ID_MENU_SAVE_AS, _("Save As"), "")
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_MENU_EXIT, _("Exit"), "")
        self.main_menubar.Append(wxglade_tmp_menu, _("File"))
        wxglade_tmp_menu = wx.Menu()

        wxglade_tmp_menu.Append(ID_MENU_ZOOM_OUT, _("Zoom Out"), "")
        wxglade_tmp_menu.Append(ID_MENU_ZOOM_IN, _("Zoom In"), "")
        wxglade_tmp_menu.Append(ID_MENU_ZOOM_SIZE, _("Zoom To Size"), "")
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_MENU_HIDE_GRID, _("Hide Grid"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_GUIDES, _("Hide Guides"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_PATH, _("Hide Paths"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_IMAGE, _("Hide Images"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_TEXT, _("Hide Text"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_FILLS, _("Hide Fills"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_STROKES, _("Hide Strokes"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_LASERPATH, _("Hide Laserpath"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_RETICLE, _("Hide Reticle"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_SELECTION, _("Hide Selection"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_SCREEN_REFRESH, _("Do Not Refresh"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_SCREEN_ANIMATE, _("Do Not Animate"), "", wx.ITEM_CHECK)
        self.main_menubar.Append(wxglade_tmp_menu, _("View"))
        wxglade_tmp_menu = wx.Menu()

        wxglade_tmp_menu.Append(ID_MENU_PREFERENCES, _("Preferences"), "")
        wxglade_tmp_menu.Append(ID_MENU_ROTARY, _("Rotary Settings"), "")
        wxglade_tmp_menu.Append(ID_MENU_KEYMAP, _("Keymap Settings"), "")
        # wxglade_tmp_menu.Append(ID_MENU_COLORDEFINE, "Color Define", "")
        wxglade_tmp_menu.Append(ID_MENU_ALIGNMENT, _("Alignment Ally"), "")

        wxglade_tmp_menu.Append(ID_MENU_NAVIGATION, _("Navigation"), "")
        wxglade_tmp_menu.Append(ID_MENU_CONTROLLER, _("Controller"), "")
        wxglade_tmp_menu.Append(ID_MENU_USB, _("USB"), "")
        wxglade_tmp_menu.Append(ID_MENU_SPOOLER, _("Job Spooler"), "")
        wxglade_tmp_menu.Append(ID_MENU_JOB, _("Execute Job"), "")

        self.main_menubar.Append(wxglade_tmp_menu, _("Windows"))

        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_MENU_WEBPAGE, _("Webpage"), "")
        self.main_menubar.Append(wxglade_tmp_menu, _("Help"))

        if os.path.exists('./locale'):
            wxglade_tmp_menu = wx.Menu()
            for i, lang in enumerate(supported_languages):
                language_code, language_name, language_index = lang
                m = wxglade_tmp_menu.Append(wx.ID_ANY, language_name, "", wx.ITEM_RADIO)
                if i == language:
                    m.Check(True)
                self.Bind(wx.EVT_MENU, self.language_to(i), id=m.GetId())
                if not os.path.exists('./locale/%s' % language_code) and i != 0:
                    m.Enable(False)
            self.main_menubar.Append(wxglade_tmp_menu, _("Languages"))
        self.SetMenuBar(self.main_menubar)
        # Menu Bar end

        self.Bind(wx.EVT_MENU, self.on_click_new, id=ID_MENU_NEW)
        self.Bind(wx.EVT_MENU, self.on_click_open, id=ID_MENU_OPEN_PROJECT)
        self.Bind(wx.EVT_MENU, self.on_click_import, id=ID_MENU_IMPORT)
        self.Bind(wx.EVT_MENU, self.on_click_save, id=ID_MENU_SAVE)
        self.Bind(wx.EVT_MENU, self.on_click_save_as, id=ID_MENU_SAVE_AS)

        self.Bind(wx.EVT_MENU, self.on_click_exit, id=ID_MENU_EXIT)
        self.Bind(wx.EVT_MENU, self.on_click_zoom_out, id=ID_MENU_ZOOM_OUT)
        self.Bind(wx.EVT_MENU, self.on_click_zoom_in, id=ID_MENU_ZOOM_IN)
        self.Bind(wx.EVT_MENU, self.on_click_zoom_size, id=ID_MENU_ZOOM_SIZE)

        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0004), id=ID_MENU_HIDE_GRID)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0002), id=ID_MENU_HIDE_GUIDES)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0400), id=ID_MENU_HIDE_PATH)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0800), id=ID_MENU_HIDE_IMAGE)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x1000), id=ID_MENU_HIDE_TEXT)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0001), id=ID_MENU_HIDE_FILLS)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0008), id=ID_MENU_HIDE_LASERPATH)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0010), id=ID_MENU_HIDE_RETICLE)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0020), id=ID_MENU_HIDE_SELECTION)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0040), id=ID_MENU_HIDE_STROKES)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0100), id=ID_MENU_SCREEN_REFRESH)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0200), id=ID_MENU_SCREEN_ANIMATE)

        self.Bind(wx.EVT_MENU, self.open_alignment, id=ID_MENU_ALIGNMENT)
        self.Bind(wx.EVT_MENU, self.open_keymap, id=ID_MENU_KEYMAP)
        # self.Bind(wx.EVT_MENU, self.open_colordefine, id=ID_MENU_COLORDEFINE)
        self.Bind(wx.EVT_MENU, self.open_preferences, id=ID_MENU_PREFERENCES)
        self.Bind(wx.EVT_MENU, self.open_rotary, id=ID_MENU_ROTARY)
        self.Bind(wx.EVT_MENU, self.open_navigation, id=ID_MENU_NAVIGATION)
        self.Bind(wx.EVT_MENU, self.open_controller, id=ID_MENU_CONTROLLER)
        self.Bind(wx.EVT_MENU, self.open_usb, id=ID_MENU_USB)
        self.Bind(wx.EVT_MENU, self.open_spooler, id=ID_MENU_SPOOLER)
        self.Bind(wx.EVT_MENU, self.open_job, id=ID_MENU_JOB)

        self.Bind(wx.EVT_MENU, self.launch_webpage, id=ID_MENU_WEBPAGE)

        toolbar.Bind(RB.EVT_RIBBONTOOLBAR_CLICKED, self.on_click_open, id=ID_OPEN)
        toolbar.Bind(RB.EVT_RIBBONTOOLBAR_CLICKED, self.on_click_save, id=ID_SAVE)
        toolbar.Bind(RB.EVT_RIBBONTOOLBAR_CLICKED, self.open_job, id=ID_JOB)

        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_usb, id=ID_USB)
        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_navigation, id=ID_NAV)
        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_controller, id=ID_CONTROLLER)
        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_preferences, id=ID_PREFERENCES)
        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_spooler, id=ID_SPOOLER)

        self.main_statusbar = self.CreateStatusBar(3)

        # end wxGlade

        self.Bind(wx.EVT_DROP_FILES, self.on_drop_file)

        self.previous_position = None
        self.project.elements_change_listener = self.tree_update

        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_FILLS)
        m.Check(self.project.draw_mode & 0x0001 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_GUIDES)
        m.Check(self.project.draw_mode & 0x0002 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_GRID)
        m.Check(self.project.draw_mode & 0x0004 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_LASERPATH)
        m.Check(self.project.draw_mode & 0x0008 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_RETICLE)
        m.Check(self.project.draw_mode & 0x0010 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_SELECTION)
        m.Check(self.project.draw_mode & 0x0020 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_STROKES)
        m.Check(self.project.draw_mode & 0x0040 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_SCREEN_REFRESH)
        m.Check(self.project.draw_mode & 0x0100 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_SCREEN_ANIMATE)
        m.Check(self.project.draw_mode & 0x0200 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_PATH)
        m.Check(self.project.draw_mode & 0x0400 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_IMAGE)
        m.Check(self.project.draw_mode & 0x0800 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_TEXT)
        m.Check(self.project.draw_mode & 0x1000 != 0)

        self.Bind(wx.EVT_TREE_BEGIN_DRAG, self.on_drag_begin_handler, self.tree)
        self.Bind(wx.EVT_TREE_END_DRAG, self.on_drag_end_handler, self.tree)
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.on_item_activated, self.tree)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_item_changed, self.tree)
        self.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self.on_item_right_click, self.tree)
        # end wxGlade
        # self.Bind(wx.EVT_BUTTON, self.on_clicked_burn, id=ID_CUT_BURN_BUTTON)
        self.refresh_tree_elements()
        # end wxGlade
        self.dragging_element = None
        # self.SetDoubleBuffered(True)

        self.matrix = ZMatrix()
        self.identity = ZMatrix()
        self.matrix.Reset()
        self.identity.Reset()
        self.previous_window_position = None
        self.previous_scene_position = None
        self.popup_window_position = None
        self.popup_scene_position = None
        self._Buffer = None
        self.screen_refresh_is_requested = True
        self.screen_refresh_is_running = False
        self.background_brush = wx.Brush("Grey")
        self.project = project
        self.renderer = LaserRender(project)
        self.grid = None
        self.guide_lines = None
        self.laserpath = [(0, 0, 0, 0)] * 1000
        self.laserpath_index = 0
        self.move_function = self.move_pan
        self.working_file = None

        self.on_size(None)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.__set_properties()
        self.__do_layout()

        self.selection_pen = wx.Pen()
        self.selection_pen.SetColour(wx.BLUE)
        self.selection_pen.SetWidth(25)
        self.selection_pen.SetStyle(wx.PENSTYLE_SHORT_DASH)

        self.scene.Bind(wx.EVT_PAINT, self.on_paint)
        self.scene.Bind(wx.EVT_ERASE_BACKGROUND, self.on_erase)

        self.scene.Bind(wx.EVT_MOTION, self.on_mouse_move)

        self.scene.Bind(wx.EVT_MOUSEWHEEL, self.on_mousewheel)

        self.scene.Bind(wx.EVT_MIDDLE_DOWN, self.on_mouse_middle_down)
        self.scene.Bind(wx.EVT_MIDDLE_UP, self.on_mouse_middle_up)

        self.scene.Bind(wx.EVT_LEFT_DCLICK, self.on_mouse_double_click)

        self.scene.Bind(wx.EVT_RIGHT_DOWN, self.on_right_mouse_down)
        self.scene.Bind(wx.EVT_RIGHT_UP, self.on_right_mouse_up)

        self.scene.Bind(wx.EVT_LEFT_DOWN, self.on_left_mouse_down)
        self.scene.Bind(wx.EVT_LEFT_UP, self.on_left_mouse_up)

        self.scene.Bind(wx.EVT_ENTER_WINDOW, lambda event: self.scene.SetFocus())  # Focus follows mouse.
        self.tree.Bind(wx.EVT_ENTER_WINDOW, lambda event: self.tree.SetFocus())  # Focus follows mouse.
        self.scene.Bind(wx.EVT_KEY_DOWN, self.on_key_press)
        bedwidth = project.bed_width
        bedheight = project.bed_height
        self.focus_viewport_scene((0, 0, bedwidth * MILS_IN_MM, bedheight * MILS_IN_MM), 0.1)

        self.Bind(wx.EVT_CLOSE, self.on_close, self)
        self.project.listen("usb_state", self.on_usb_status)
        self.project.listen("control_thread", self.on_control_state)
        self.project.listen("writer", self.on_writer_state)
        self.project.listen("elements", self.on_elements_update)
        self.project.listen("position", self.update_position)
        self.project.listen("units", self.space_changed)
        self.project.listen("selection", self.selection_changed)
        self.project.listen("bed_size", self.bed_changed)
        self.project.listen("elements", self.elements_changed)
        self.project.listen("writer_mode", self.on_writer_mode)
        self.space_changed(0)
        self.default_keymap()
        self.fps_job = self.project.cron.add_job(self.refresh_scene, interval=1.0 / float(project.fps))

    def set_fps(self, fps):
        if fps == 0:
            fps = 1
        self.fps_job.times = 0
        self.project.fps = fps
        self.fps_job = self.project.cron.add_job(self.refresh_scene, interval=1.0 / float(project.fps))

    def on_elements_update(self, *args):
        """
        Called by 'elements' change. To refresh tree.

        :param args:
        :return:
        """
        self.refresh_tree_elements()

    def on_drag_begin_handler(self, event):  # wxGlade: CutConfiguration.<event_handler>
        """
        Drag handler begin for the tree.

        :param event:
        :return:
        """
        self.dragging_element = None
        item = event.GetItem()
        element = self.tree.GetItemData(item)
        self.dragging_element = element
        event.Allow()

    def on_drag_end_handler(self, event):  # wxGlade: CutConfiguration.<event_handler>
        """
        Drag handler end for the tree

        :param event:
        :return:
        """
        if self.dragging_element is None:
            event.Skip()
            return
        drag_element = self.dragging_element
        drag_parent = self.dragging_element.parent
        self.dragging_element = None

        item = event.GetItem()
        if item is None:
            event.Skip()
            return
        if item.ID is None:
            event.Skip()
            return
        drop_element = self.tree.GetItemData(item)
        if drop_element is None:
            event.Skip()
            return

        if drag_element == drop_element or drop_element.type not in ('group', 'root'):
            # Cannot drop into other laser elements.
            event.Skip()
            return

        drag_parent.remove(drag_element)
        if len(drag_parent) == 0 and drag_parent.type == 'group' and drag_parent.name is None:
            drag_parent.parent.remove(drag_parent)

        if drop_element.type == 'root':  # Project
            if drag_element.type != 'group':
                group = LaserNode()
                group.append(drag_element)
                group.update(drag_element)  # Group gets element property.
                drop_element.append(group)
            else:
                drop_element.append(drag_element)
            event.Allow()
            return
        if drop_element.type == 'group':  # Group
            drop_element.append(drag_element)
            event.Allow()
            return
        event.Skip()

    def on_item_right_click(self, event):
        """
        Right click of element in tree.

        :param event:
        :return:
        """
        item = event.GetItem()
        if item is None:
            return
        if item.ID is None:
            return
        element = self.tree.GetItemData(item)
        if element is not None:
            project.set_selected(element)
            create_menu(element)
        event.Skip()

    def on_item_activated(self, event):  # wxGlade: CutConfiguration.<event_handler>
        """
        Tree item is double-clicked. Launches ElementProperty dialog.

        :param event:
        :return:
        """
        item = event.GetItem()
        element = self.tree.GetItemData(item)
        if element is not None:
            self.project.open_window("ElementProperty").set_elements(element)

    def on_item_changed(self, event):
        """
        Tree menu item is changed. Modify the selection.

        :param event:
        :return:
        """
        item = event.GetItem()
        element = self.tree.GetItemData(item)
        if element is not None:
            project.set_selected(element)

    def add_element(self, tree, node, element):
        """
        Add a element to the tree.

        :param tree:
        :param node:
        :param element:
        :return:
        """
        if element.passes == 1:
            item = tree.AppendItem(node, str(element))
        else:
            item = tree.AppendItem(node, "%d pass, %s" % (element.passes, str(element)))
        tree.SetItemData(item, element)
        try:
            tree.SetItemBackgroundColour(item, wx.Colour(swizzlecolor(element.fill)))
        except AttributeError:
            pass
        try:
            tree.SetItemTextColour(item, wx.Colour(swizzlecolor(element.stroke)))
        except AttributeError:
            pass
        t = element.type
        if t == 'image':
            image = self.renderer.make_thumbnail(element, width=20, height=20)
        else:
            image = self.renderer.make_raster(element, width=20, height=20, bitmap=True)
        if image is not None:
            id = self.tree_images.Add(bitmap=image)
            tree.SetItemImage(item, image=id)
        for subitem in element:
            self.add_element(tree, item, subitem)

    def refresh_tree_elements(self):
        """
        Rebuild tree elements

        :return:
        """
        tree = self.tree
        tree.DeleteAllItems()
        root = self.tree.AddRoot(str(project.elements))
        self.tree.SetItemData(root, project.elements)
        for subitem in project.elements:
            self.add_element(tree, root, subitem)
        tree.CollapseAll()
        tree.ExpandAll()

    def on_usb_status(self, value):
        self.main_statusbar.SetStatusText(_("Usb: %s" % value), 0)

    def on_control_state(self, value):
        self.main_statusbar.SetStatusText(_("Controller: %s" % project.get_state_string_from_state(value)), 1)

    def on_writer_state(self, value):
        self.main_statusbar.SetStatusText(_("Spooler: %s" % project.get_state_string_from_state(value)), 2)

    def on_writer_mode(self, state):
        if state == 0:
            self.background_brush = wx.Brush("Grey")
        else:
            self.background_brush = wx.Brush("Red")
        self.request_refresh_for_animation()

    def on_close(self, event):
        if self.project.spooler.thread.state == THREAD_STATE_STARTED or \
                self.project.controller.thread.state == THREAD_STATE_STARTED:
            dlg = wx.MessageDialog(None, _("Issue emergency stop and close?"),
                                   _('Processes are still running.'), wx.OK | wx.CANCEL | wx.ICON_WARNING)
            result = dlg.ShowModal()
            dlg.Destroy()

            if result == wx.ID_OK:
                project.execute("Emergency Stop")
                self.project("abort", 1)
            else:
                return
        for window in [value for key, value in self.project.open_windows.items()]:
            window.Close()
        self.project.unlisten("usb_state", self.on_usb_status)
        self.project.unlisten("control_thread", self.on_control_state)
        self.project.unlisten("writer", self.on_writer_state)
        self.project.flush()
        self.project.shutdown()
        self.project.unlisten("position", self.update_position)
        self.project.unlisten("units", self.space_changed)
        self.project.unlisten("selection", self.selection_changed)
        self.project.unlisten("bed_size", self.bed_changed)
        self.project.unlisten("elements", self.elements_changed)
        event.Skip()  # Call destroy as regular.

    def __set_properties(self):
        # begin wxGlade: MeerK40t.__set_properties
        self.SetTitle(_("MeerK40t v%s" % MEERK40T_VERSION))
        self.main_statusbar.SetStatusWidths([-1] * self.main_statusbar.GetFieldsCount())
        _icon = wx.NullIcon
        _icon.CopyFromBitmap(icon_meerk40t.GetBitmap())
        self.SetIcon(_icon)
        # statusbar fields
        main_statusbar_fields = ["Status"]
        for i in range(len(main_statusbar_fields)):
            self.main_statusbar.SetStatusText(main_statusbar_fields[i], i)
        # self.main_toolbar.Realize()

        # self.scene.SetMinSize((1000, 880))
        # self.scene.SetBackgroundColour(wx.Colour(200,200,200))
        # end wxGlade

    def __do_layout(self):
        main_sizer = wx.BoxSizer(wx.VERTICAL)
        main_sizer.Add(self._ribbon, 1, wx.EXPAND, 0)
        widget_sizer = wx.BoxSizer(wx.HORIZONTAL)
        widget_sizer.Add(self.tree, 1, wx.EXPAND, 0)
        widget_sizer.Add(self.scene, 5, wx.ALL | wx.EXPAND, 2)
        main_sizer.Add(widget_sizer, 5, wx.EXPAND, 0)
        self.SetSizer(main_sizer)
        # main_sizer.Fit(self)
        self.Layout()

    def load_file(self, pathname, group=None):
        return self.project.load(pathname, group)

    def on_drop_file(self, event):
        """
        Drop file handler

        Accepts multiple files drops.
        """
        accepted = 0
        rejected = 0
        rejected_files = []
        for pathname in event.GetFiles():
            if self.load_file(pathname):
                accepted += 1
            else:
                rejected += 1
                rejected_files.append(pathname)
        if rejected != 0:
            reject = "\n".join(rejected_files)
            err_msg = _("Some files were unrecognized:\n%s" % reject)
            dlg = wx.MessageDialog(None, err_msg, _('Error encountered'), wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()
        self.refresh_tree_elements()

    def load_svg(self, pathname, group=None):
        """
        Load SVG File. Scalable Vector Graphics
        """
        self.project.load(pathname, group)
        self.request_refresh()

    def load_egv(self, pathname, group=None):
        """
        Load egv files. Engrave files.
        """
        self.project.load(pathname, group)
        self.request_refresh()

    def load_image(self, pathname, group=None):
        """
        Load image files.
        """
        self.project.load(pathname, group)
        self.request_refresh()

    def tree_update(self):
        self.refresh_tree_elements()

    def on_paint(self, event):
        try:
            wx.BufferedPaintDC(self.scene, self._Buffer)
        except RuntimeError:
            pass

    def on_size(self, event):
        self.Layout()
        width, height = self.scene.ClientSize
        if width <= 0:
            width = 1
        if height <= 0:
            height = 1
        self._Buffer = wx.Bitmap(width, height)
        self.project.window_width, self.project.window_height = self.Size
        self.guide_lines = None
        self.request_refresh()

    def update_position(self, pos):
        # x, y, old_x, old_y = pos
        self.laserpath[self.laserpath_index] = pos
        self.laserpath_index += 1
        self.laserpath_index %= len(self.laserpath)
        self.request_refresh_for_animation()

    def space_changed(self, units):
        self.grid = None
        self.on_size(None)

    def bed_changed(self, size):
        self.grid = None
        self.on_size(None)

    def selection_changed(self, selection):
        self.request_refresh()

    def elements_changed(self, e):
        self.request_refresh()

    def on_erase(self, event):
        pass

    def request_refresh_for_animation(self):
        """Called on the various signals trying to animate the screen."""
        if self.project.draw_mode & 0x0200 == 0:
            self.request_refresh()

    def request_refresh(self):
        """Request an update to the scene."""
        if self.project.draw_mode & 0x0100 == 0:
            self.screen_refresh_is_requested = True

    def refresh_scene(self):
        """Called by the Scheduler at a given the specified framerate."""
        if self.screen_refresh_is_requested and not self.screen_refresh_is_running:
            self.screen_refresh_is_running = True
            wx.CallAfter(self.refresh_in_ui)

    def refresh_in_ui(self):
        """Called by refresh_scene() in the UI thread."""
        self.update_buffer_ui_thread()
        self.Refresh()
        self.screen_refresh_is_requested = False
        self.screen_refresh_is_running = False

    def update_buffer_ui_thread(self):
        """Performs the redraw of the data in the UI thread."""
        dc = wx.MemoryDC()
        dc.SelectObject(self._Buffer)
        self.on_draw_background(dc)
        if dc.CanUseTransformMatrix():
            dc.SetTransformMatrix(self.matrix)
            self.on_draw_scene(dc)
            dc.SetTransformMatrix(self.identity)
        else:
            original_font = dc.GetFont()
            font = wx.Font(20, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_LIGHT)
            dc.SetFont(font)
            dc.SetPen(wx.BLACK_PEN)
            s = dc.GetSize() / 2
            dc.DrawText(_("Current OS cannot use transformation matrix. Skipping scene draw."), s[0] - 350, s[1])
            dc.SetFont(original_font)
        self.on_draw_interface(dc)
        del dc

    def on_matrix_change(self):
        self.guide_lines = None

    def scene_matrix_reset(self):
        self.matrix.Reset()
        self.on_matrix_change()

    def scene_post_scale(self, sx, sy=None, ax=0, ay=0):
        self.matrix.PostScale(sx, sy, ax, ay)
        self.on_matrix_change()

    def scene_post_pan(self, px, py):
        self.matrix.PostTranslate(px, py)
        self.on_matrix_change()

    def scene_post_rotate(self, angle, rx=0, ry=0):
        self.matrix.PostRotate(angle, rx, ry)
        self.on_matrix_change()

    def scene_pre_scale(self, sx, sy=None, ax=0, ay=0):
        self.matrix.PreScale(sx, sy, ax, ay)
        self.on_matrix_change()

    def scene_pre_pan(self, px, py):
        self.matrix.PreTranslate(px, py)
        self.on_matrix_change()

    def scene_pre_rotate(self, angle, rx=0, ry=0):
        self.matrix.PreRotate(angle, rx, ry)
        self.on_matrix_change()

    def get_scale_x(self):
        return self.matrix.GetScaleX()

    def get_scale_y(self):
        return self.matrix.GetScaleY()

    def get_skew_x(self):
        return self.matrix.GetSkewX()

    def get_skew_y(self):
        return self.matrix.GetSkewY()

    def get_translate_x(self):
        return self.matrix.GetTranslateX()

    def get_translate_y(self):
        return self.matrix.GetTranslateY()

    def on_mousewheel(self, event):
        rotation = event.GetWheelRotation()
        mouse = event.GetPosition()
        if self.project.mouse_zoom_invert:
            rotation = -rotation
        if rotation > 1:
            self.scene_post_scale(1.1, 1.1, mouse[0], mouse[1])
        elif rotation < -1:
            self.scene_post_scale(0.9, 0.9, mouse[0], mouse[1])
        self.request_refresh()

    def on_mouse_middle_down(self, event):
        self.SetCursor(wx.Cursor(wx.CURSOR_HAND))
        self.scene.CaptureMouse()
        self.previous_window_position = event.GetPosition()
        self.previous_scene_position = self.convert_window_to_scene(self.previous_window_position)

    def on_mouse_middle_up(self, event):
        if self.scene.HasCapture():
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.scene.ReleaseMouse()
        self.previous_window_position = None
        self.previous_scene_position = None

    def on_left_mouse_down(self, event):
        self.SetCursor(wx.Cursor(wx.CURSOR_HAND))
        self.scene.CaptureMouse()
        self.previous_window_position = event.GetPosition()
        self.previous_scene_position = self.convert_window_to_scene(self.previous_window_position)
        self.renderer.set_selected_by_position(self.previous_scene_position)
        self.move_function = self.move_selected

    def on_left_mouse_up(self, event):
        if self.scene.HasCapture():
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.scene.ReleaseMouse()
        self.previous_window_position = None
        self.previous_scene_position = None
        self.move_function = self.move_pan
        self.renderer.validate()

    def on_mouse_double_click(self, event):
        position = event.GetPosition()
        position = self.convert_window_to_scene(position)
        self.renderer.set_selected_by_position(position)
        if self.project.selected is not None:
            window = self.project.open_window("ElementProperty")
            window.set_elements(self.project.selected)

    def move_pan(self, wdx, wdy, sdx, sdy):
        self.scene_post_pan(wdx, wdy)
        self.request_refresh()

    def move_selected(self, wdx, wdy, sdx, sdy):
        self.project.move_selected(sdx, sdy)
        self.request_refresh()

    def on_mouse_move(self, event):
        if not event.Dragging():
            return
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_HAND))
        if self.previous_window_position is None:
            return

        pos = event.GetPosition()
        window_position = pos.x, pos.y
        scene_position = self.convert_window_to_scene([window_position[0], window_position[1]])
        sdx = (scene_position[0] - self.previous_scene_position[0])
        sdy = (scene_position[1] - self.previous_scene_position[1])
        wdx = (window_position[0] - self.previous_window_position[0])
        wdy = (window_position[1] - self.previous_window_position[1])
        self.move_function(wdx, wdy, sdx, sdy)
        self.previous_window_position = window_position
        self.previous_scene_position = scene_position

    def on_right_mouse_down(self, event):
        self.popup_window_position = event.GetPosition()
        self.popup_scene_position = self.convert_window_to_scene(self.popup_window_position)
        self.renderer.set_selected_by_position(self.popup_scene_position)
        create_menu(self.project.selected)

    def on_right_mouse_up(self, event):
        self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))

    def default_keymap(self):
        self.project.keymap[wx.WXK_RIGHT] = MappedKey("right", "move right 1mm")
        self.project.keymap[wx.WXK_LEFT] = MappedKey("left", "move left 1mm")
        self.project.keymap[wx.WXK_UP] = MappedKey("up", "move up 1mm")
        self.project.keymap[wx.WXK_DOWN] = MappedKey("down", "move down 1mm")
        self.project.keymap[ord('1')] = MappedKey('1', "set_position 1")
        self.project.keymap[ord('2')] = MappedKey('2', "set_position 2")
        self.project.keymap[ord('3')] = MappedKey('3', "set_position 3")
        self.project.keymap[ord('4')] = MappedKey('4', "set_position 4")
        self.project.keymap[ord('5')] = MappedKey('5', "set_position 5")
        self.project.keymap[wx.WXK_F6] = MappedKey('F6', "window JobSpooler")
        self.project.keymap[wx.WXK_F7] = MappedKey('F7', "window Controller")
        self.project.keymap[wx.WXK_F8] = MappedKey('F8', "control Path")

    def execute_string_action(self, action, *args):
        writer = self.project.spooler
        if action == 'move':
            writer.send_job(self.execute_move_action(*args))
        elif action == 'move_to':
            writer.send_job(self.execute_move_to_action(*args))
        elif action == 'set_position':
            self.execute_set_position_action(*args)
        elif action == 'window':
            self.execute_open_window_action(*args)
        elif action == 'control':
            self.execute_execute_control(*args)

    def execute_execute_control(self, *args):
        self.project.execute(args[0])

    def execute_open_window_action(self, *args):
        window_name = args[0]
        if window_name in self.project.windows:
            self.project.open_window(window_name)

    def execute_set_position_action(self, index):
        x = self.project.spooler.current_x
        y = self.project.spooler.current_y
        self.project.keymap[ord(index)] = MappedKey(index, "move_to %d %d" % (x, y))

    def execute_move_action(self, direction, amount):
        min_dim = min(project.window_width, project.window_height)
        amount = Length(amount).value(ppi=1000.0, relative_length=min_dim)
        x = 0
        y = 0
        if direction == 'right':
            x = amount
        elif direction == 'left':
            x = -amount
        elif direction == 'up':
            y = -amount
        elif direction == 'down':
            y = amount

        def move():
            yield COMMAND_SET_INCREMENTAL
            yield COMMAND_RAPID_MOVE, (x, y)
            yield COMMAND_SET_ABSOLUTE

        return move

    def execute_move_to_action(self, position_x, position_y):
        def move():
            yield COMMAND_RAPID_MOVE, (int(position_x), int(position_y))

        return move

    def on_key_press(self, event):
        keycode = event.GetKeyCode()
        if keycode in self.project.keymap:
            action = self.project.keymap[keycode].command
            args = str(action).split(' ')
            self.execute_string_action(*args)

    def focus_on_project(self):
        bbox = self.renderer.bbox(self.project.elements)
        if bbox is None:
            return
        self.focus_viewport_scene(bbox)
        self.request_refresh()

    def focus_position_scene(self, scene_point):
        window_width, window_height = self.scene.ClientSize
        scale_x = self.get_scale_x()
        scale_y = self.get_scale_y()
        self.scene_matrix_reset()
        self.scene_post_pan(-scene_point[0], -scene_point[1])
        self.scene_post_scale(scale_x, scale_y)
        self.scene_post_pan(window_width / 2.0, window_height / 2.0)

    def focus_viewport_scene(self, new_scene_viewport, buffer=0.0, lock=True):
        window_width, window_height = self.scene.ClientSize
        left = new_scene_viewport[0]
        top = new_scene_viewport[1]
        right = new_scene_viewport[2]
        bottom = new_scene_viewport[3]
        viewport_width = right - left
        viewport_height = bottom - top

        left -= viewport_width * buffer
        right += viewport_width * buffer
        top -= viewport_height * buffer
        bottom += viewport_height * buffer

        if right == left:
            scale_x = 100
        else:
            scale_x = window_width / float(right - left)
        if bottom == top:
            scale_y = 100
        else:
            scale_y = window_height / float(bottom - top)

        cx = ((right + left) / 2)
        cy = ((top + bottom) / 2)
        self.matrix.Reset()
        self.matrix.PostTranslate(-cx, -cy)
        if lock:
            scale = min(scale_x, scale_y)
            if scale != 0:
                self.matrix.PostScale(scale)
        else:
            if scale_x != 0 and scale_y != 0:
                self.matrix.PostScale(scale_x, scale_y)
        self.matrix.PostTranslate(window_width / 2.0, window_height / 2.0)

    def convert_scene_to_window(self, position):
        return self.matrix.TransformPoint([position[0], position[1]])

    def convert_window_to_scene(self, position):
        return self.matrix.InverseTransformPoint([position[0], position[1]])

    def calculate_grid(self):
        lines = []
        p = self.project
        wmils = p.bed_width * 39.37
        hmils = p.bed_height * 39.37
        convert = p.units_convert
        marks = p.units_marks
        step = convert * marks
        if step == 0:
            self.grid = []
            return
        x = 0.0
        while x < wmils:
            lines.append((x, 0, x, hmils))
            x += step
        y = 0.0
        while y < hmils:
            lines.append((0, y, wmils, y))
            y += step
        self.grid = lines

    def on_draw_grid(self, dc):
        if self.grid is None:
            self.calculate_grid()
        dc.DrawLineList(self.grid)

    def on_draw_guides(self, dc):
        lines = []
        w, h = self.Size
        p = self.project
        scaled_conversion = p.units_convert * self.matrix.GetScaleX()
        if scaled_conversion == 0:
            return

        wpoints = w / 15.0
        hpoints = h / 15.0
        points = min(wpoints, hpoints)
        # tweak the scaled points into being useful.
        # points = scaled_conversion * round(points / scaled_conversion * 10.0) / 10.0
        points = scaled_conversion * float('{:.1g}'.format(points / scaled_conversion))
        sx, sy = self.convert_scene_to_window([0, 0])
        if points == 0:
            return
        offset_x = sx % points
        offset_y = sy % points

        x = offset_x
        length = 50

        while x < w:
            lines.append((x, 0, x, length))
            lines.append((x, h, x, h - length))
            mark_point = (x - sx) / scaled_conversion
            if round(mark_point * 1000) == 0:
                mark_point = 0.0  # prevents -0
            dc.DrawRotatedText("%g %s" % (mark_point, p.units_name), x, 0, -90)
            x += points

        y = offset_y
        while y < h:
            lines.append((0, y, length, y))
            lines.append((w, y, w - length, y))
            mark_point = (y - sy) / scaled_conversion
            if round(mark_point * 1000) == 0:
                mark_point = 0.0  # prevents -0
            dc.DrawText("%g %s" % (mark_point + 0, p.units_name), 0, y + 0)
            y += points
        dc.DrawLineList(lines)

    def on_draw_background(self, dc):
        dc.SetBackground(self.background_brush)
        dc.Clear()

    def on_draw_interface(self, dc):
        pen = wx.Pen(wx.BLACK)
        pen.SetWidth(1)
        pen.SetCap(wx.CAP_BUTT)
        dc.SetPen(pen)
        if self.project.draw_mode & 2 == 0:
            self.on_draw_guides(dc)
        if self.project.draw_mode & 16 == 0:
            dc.SetPen(wx.RED_PEN)
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            x = self.project.spooler.current_x
            y = self.project.spooler.current_y
            x, y = self.convert_scene_to_window([x, y])
            dc.DrawCircle(x, y, 10)

    def on_draw_bed(self, dc):
        wmils = self.project.bed_width * 39.37
        hmils = self.project.bed_height * 39.37
        dc.SetBrush(wx.WHITE_BRUSH)
        dc.DrawRectangle(0, 0, wmils, hmils)

    def on_draw_selection(self, dc, draw_mode):
        if self.project.selected is not None and self.project.selected.scene_bounds is not None:
            linewidth = 3.0 / self.matrix.GetScaleX()
            # f = 2 * linewidth
            # g = 2 * f
            self.selection_pen.SetWidth(linewidth)
            dc.SetPen(self.selection_pen)
            dc.SetBrush(wx.BLACK_BRUSH)
            x0, y0, x1, y1 = self.project.selected.scene_bounds
            center_x = (x0 + x1) / 2.0
            center_y = (y0 + y1) / 2.0
            dc.DrawLine(center_x, 0, center_x, y0)
            dc.DrawLine(0, center_y, x0, center_y)
            dc.DrawLine(x0, y0, x1, y0)
            dc.DrawLine(x1, y0, x1, y1)
            dc.DrawLine(x1, y1, x0, y1)
            dc.DrawLine(x0, y1, x0, y0)
            if draw_mode & 128 == 0:
                p = self.project
                conversion, name, marks, index = p.units_convert, p.units_name, p.units_marks, p.units_index
                dc.DrawText("%.1f%s" % (y0 / conversion, name), center_x, y0)
                dc.DrawText("%.1f%s" % (x0 / conversion, name), x0, center_y)
                dc.DrawText("%.1f%s" % ((y1 - y0) / conversion, name), x1, center_y)
                dc.DrawText("%.1f%s" % ((x1 - x0) / conversion, name), center_x, y1)

    def on_draw_laserpath(self, dc, draw_mode):
        dc.SetPen(wx.BLUE_PEN)
        dc.DrawLineList(self.laserpath)

    def on_draw_scene(self, dc):
        self.on_draw_bed(dc)
        dc.SetPen(wx.BLACK_PEN)
        if self.project.draw_mode & 4 == 0:
            self.on_draw_grid(dc)
        pen = wx.Pen(wx.BLACK)
        pen.SetWidth(1)
        pen.SetCap(wx.CAP_BUTT)
        dc.SetPen(pen)
        if self.project is None:
            return
        self.renderer.render(dc, self.project.draw_mode)
        if self.project.draw_mode & 32 == 0:
            self.on_draw_selection(dc, self.project.draw_mode)
        if self.project.draw_mode & 8 == 0:
            self.on_draw_laserpath(dc, self.project.draw_mode)

    def on_click_new(self, event):  # wxGlade: MeerK40t.<event_handler>
        self.project.elements = LaserNode(parent=self.project)
        self.request_refresh()
        self.tree_update()
        # self.Refresh()

    def on_click_open(self, event):  # wxGlade: MeerK40t.<event_handler>
        # This code should load just specific project files rather than all importable formats.
        files = self.project.load_types()
        with wx.FileDialog(self, _("Open"), wildcard=files,
                           style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return  # the user changed their mind
            pathname = fileDialog.GetPath()
            self.load_file(pathname)

    def on_click_import(self, event):  # wxGlade: MeerK40t.<event_handler>
        files = "All valid types|*.svg;*.egv;*.png;*.jpg;*.jpeg|" \
                "Scalable Vector Graphics svg (*.svg)|*.svg|" \
                "Engrave egv (*.egv)|*.egv|" \
                "Portable Ne/twork Graphics png (*.png)|*.png"
        with wx.FileDialog(self, _("Open"), wildcard=files,
                           style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return  # the user changed their mind
            pathname = fileDialog.GetPath()
            self.load_file(pathname)

    def on_click_save(self, event):
        if self.working_file is None:
            self.on_click_save_as(event)

    def on_click_save_as(self, event):
        files = self.project.save_types()
        with wx.FileDialog(self, "Save Project", wildcard=files,
                           style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return  # the user changed their mind
            pathname = fileDialog.GetPath()
            if not pathname.lower().endswith('.svg'):
                pathname += '.svg'
            self.project.save(pathname)

    def on_click_exit(self, event):  # wxGlade: MeerK40t.<event_handler>
        self.Close()

    def on_click_zoom_out(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Zoomout button press
        """
        m = self.scene.ClientSize / 2
        self.scene_post_scale(1.0 / 1.5, 1.0 / 1.5, m[0], m[1])
        self.request_refresh()

    def on_click_zoom_in(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Zoomin button press
        """
        m = self.scene.ClientSize / 2
        self.scene_post_scale(1.5, 1.5, m[0], m[1])
        self.request_refresh()

    def on_click_zoom_size(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Zoom size button press.
        """
        self.focus_on_project()

    def toggle_draw_mode(self, bits):
        """
        Toggle the draw mode.
        :param bits: Bit to toggle.
        :return: Toggle function.
        """

        def toggle(event):
            self.project.draw_mode ^= bits
            self.request_refresh()

        return toggle

    def open_fps_dialog(self):
        dlg = wx.TextEntryDialog(self, _("Enter FPS Limit"), _("FPS Limit Entry"), '')
        dlg.SetValue('')

        if dlg.ShowModal() == wx.ID_OK:
            fps = dlg.GetValue()
            self.set_fps(int(fps))
        dlg.Destroy()

    def open_path_dialog(self):
        dlg = wx.TextEntryDialog(self, _("Enter SVG Path Data"), _("Path Entry"), '')
        dlg.SetValue('')

        if dlg.ShowModal() == wx.ID_OK:
            path = Path(dlg.GetValue())
            path.fill = 'black'
            path.stroke = 'black'
            group = LaserNode()
            group.name = 'Path'
            self.project.elements.append(group)
            group.append(LaserNode(abs(path)))
        dlg.Destroy()

    def open_preferences(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open preference dialog.

        :param event:
        :return:
        """
        self.project.open_window("Preferences")

    def open_rotary(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open rotary dialog.

        :param event:
        :return:
        """
        self.project.open_window("Rotary")

    def open_alignment(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Alignment Ally dialog.

        :param event:
        :return:
        """
        self.project.open_window("Alignment")

    def open_keymap(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Keymap dialog.

        :param event:
        :return:
        """
        self.project.open_window("Keymap")

    def open_colordefine(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open ColorDefine dialog

        :param event:
        :return:
        """
        self.project.open_window("ColorDefine")

    def open_usb(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open USB Log dialog.

        :param event:
        :return:
        """
        self.project.open_window("UsbConnect")

    def open_navigation(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Navigation dialog.

        :param event:
        :return:
        """
        self.project.open_window("Navigation")

    def open_controller(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Controller dialog.

        :param event:
        :return:
        """
        self.project.open_window("Controller")

    def open_spooler(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Job Spooler.

        :param event:
        :return:
        """
        self.project.open_window("JobSpooler")

    def open_job(self, event=None):
        """
        Open Execute Job dialog.

        :param event:
        :return:
        """
        window = self.project.open_window("JobInfo")
        elements = [e for e in self.project.elements.flat_elements(types=('image', 'path', 'text'), passes=True)]
        window.set_elements(elements)

    def launch_webpage(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Launch webpage

        :param event:
        :return:
        """
        import webbrowser
        webbrowser.open(MEERK40T_WEBSITE, new=0, autoraise=True)

    def language_swap(self, lang):
        def update(event):
            self.Unbind(wx.EVT_CLOSE, self)
            self.language_to(lang)
            self.project.flush()
            self.Close(True)
            window = MeerK40t(None, wx.ID_ANY, "")
            window.Show()

        return update

    def language_to(self, lang):
        """
        Returns a function to change the language to the language specified.
        :param lang: language to switch to
        :return:
        """

        def update_language(event):
            """
            Update language to the requested language.
            """
            language_code, language_name, language_index = supported_languages[lang]
            project.language = lang

            if self.locale:
                assert sys.getrefcount(self.locale) <= 2
                del self.locale
            self.locale = wx.Locale(language_index)
            if self.locale.IsOk():
                self.locale.AddCatalog('meerk40t')
            else:
                self.locale = None
            project('language', (lang, language_code, language_name, language_index))

        return update_language


# end of class MeerK40t


def create_menu(element):
    """Create menu items. This is used for both the scene and the tree to create menu items."""
    if element is None:
        return
    gui = MeerK40tApp.MeerK40t
    menu = wx.Menu()
    t = element.type
    if t != 'root':
        gui.Bind(wx.EVT_MENU, menu_remove(element),
                 menu.Append(wx.ID_ANY, _("Remove %s") % str(element)[:16], "", wx.ITEM_NORMAL))
        if t == 'group':
            fpath = element['filepath']
            if fpath is not None:
                name = os.path.basename(fpath)
                gui.Bind(wx.EVT_MENU, menu_reload(element),
                         menu.Append(wx.ID_ANY, _("Reload %s") % name, "", wx.ITEM_NORMAL))
                if len(element) > 1:
                    gui.Bind(wx.EVT_MENU, menu_reverse_order(element),
                             menu.Append(wx.ID_ANY, _("Reverse Layer Order"), "", wx.ITEM_NORMAL))
        gui.Bind(wx.EVT_MENU, menu_hull(element), menu.Append(wx.ID_ANY, _("Convex Hull"), "", wx.ITEM_NORMAL))
        gui.Bind(wx.EVT_MENU, menu_execute(element), menu.Append(wx.ID_ANY, _("Execute Job"), "", wx.ITEM_NORMAL))
        gui.Bind(wx.EVT_MENU, menu_reset(element),
                 menu.Append(wx.ID_ANY, _("Reset User Changes"), "", wx.ITEM_NORMAL))
        path_scale_sub_menu = wx.Menu()
        for i in range(1, 25):
            gui.Bind(wx.EVT_MENU, menu_scale(element, 6.0 / float(i)),
                     path_scale_sub_menu.Append(wx.ID_ANY, _("Scale %.0f%%" % (600.0 / float(i))), "", wx.ITEM_NORMAL))
        menu.AppendSubMenu(path_scale_sub_menu, _("Scale"))
        path_rotate_sub_menu = wx.Menu()
        for i in range(2, 13):
            angle = Angle.turns(1.0 / float(i))
            gui.Bind(wx.EVT_MENU, menu_rotate(element, 1.0 / float(i)),
                     path_rotate_sub_menu.Append(wx.ID_ANY, _(u"Rotate turn/%d, %.0f°" % (i, angle.as_degrees)), "",
                                                 wx.ITEM_NORMAL))
        for i in range(2, 13):
            angle = Angle.turns(1.0 / float(i))
            gui.Bind(wx.EVT_MENU, menu_rotate(element, -1.0 / float(i)),
                     path_rotate_sub_menu.Append(wx.ID_ANY, _(u"Rotate turn/%d, -%.0f°" % (i, angle.as_degrees)), "",
                                                 wx.ITEM_NORMAL))
        menu.AppendSubMenu(path_rotate_sub_menu, _("Rotate"))
    if element.contains_type('path'):
        vector_menu = wx.Menu()
        gui.Bind(wx.EVT_MENU, menu_subpath(element),
                 vector_menu.Append(wx.ID_ANY, _("Break Subpaths"), "", wx.ITEM_NORMAL))
        gui.Bind(wx.EVT_MENU, menu_raster(element),
                 vector_menu.Append(wx.ID_ANY, _("Make Raster Image"), "", wx.ITEM_NORMAL))
        gui.Bind(wx.EVT_MENU, menu_reify(element),
                 menu.Append(wx.ID_ANY, _("Reify User Changes"), "", wx.ITEM_NORMAL))
        menu.AppendSubMenu(vector_menu, _("Vector"))
    if element.contains_type('image'):
        image_menu = wx.Menu()
        gui.Bind(wx.EVT_MENU, menu_raster_actualize(element),
                 image_menu.Append(wx.ID_ANY, _("Actualize Pixels"), "", wx.ITEM_NORMAL))
        gui.Bind(wx.EVT_MENU, menu_dither(element),
                 image_menu.Append(wx.ID_ANY, _("Dither to 1 bit"), "", wx.ITEM_NORMAL))
        gui.Bind(wx.EVT_MENU, menu_raster_native(element),
                 image_menu.Append(wx.ID_ANY, _("Set to Native"), "", wx.ITEM_NORMAL))
        image_sub_menu_step = wx.Menu()
        for i in range(1, 8):
            gui.Bind(wx.EVT_MENU, menu_step(element, i),
                     image_sub_menu_step.Append(wx.ID_ANY, _("Step %d") % i, "", wx.ITEM_NORMAL))
        image_menu.AppendSubMenu(image_sub_menu_step, _("Step"))
        menu.AppendSubMenu(image_menu, _("Raster"))
    if element.contains_type('text'):
        text_menu = wx.Menu()
        gui.Bind(wx.EVT_MENU, menu_remove(element, types=(SVGText)),
                 text_menu.Append(wx.ID_ANY, _("Remove Text"), "", wx.ITEM_NORMAL))
        menu.Append(wx.ID_ANY, "Text", text_menu)
    if menu.MenuItemCount != 0:
        gui.PopupMenu(menu)
        menu.Destroy()


def menu_scale(element, value):
    """
    Menu scale.

    :param element:
    :param value:
    :return:
    """

    def specific(event):
        center = element.center
        if center is not None:
            for e in element.flat_elements(types=('image', 'path', 'text')):
                e.element.transform.post_scale(value, value, center[0], center[1])
            project("elements", 0)

    return specific


def menu_step(element, step_value):
    """
    Change raster step values of subelements.

    :param element:
    :param step_value:
    :return:
    """

    def specific(event):
        for e in element.flat_elements(types=('image')):
            old_step = e.raster_step
            e.raster_step = step_value
            scale = float(step_value) / float(old_step)
            m = e.transform
            e.transform.post_scale(scale, scale, m.e, m.f)
        project("elements", 0)

    return specific


def menu_raster_actualize(element):
    """
    Causes the raster image to be native at the current scale by rotating, scaling, skewing etc.

    :param element:
    :return:
    """

    def specific(event):
        for e in element.flat_elements(types=('image')):
            e.make_actual()
        project(_("elements"), 0)

    return specific


def menu_raster_native(element):
    """
    Reset the raster to native form validating the matrix for the given step value.

    :param element:
    :return:
    """

    def specific(event):
        for e in element.flat_elements(types=('image')):
            e.set_native()
        project("elements", 0)

    return specific


def menu_dither(element):
    """
    Change raster dither forcing raster elements to 1 bit.

    :param element:
    :return:
    """

    def specific(event):
        for e in element.flat_elements(types=('image')):
            e.element.image = e.element.image.convert("1")
            e.cache = None
        project("elements", 0)

    return specific


def menu_raster(element):
    """
    Convert a vector element into a raster element.

    :param element:
    :return:
    """

    def specific(event):
        renderer = LaserRender(project)
        image = renderer.make_raster(element, types='path')
        xmin, ymin, xmax, ymax = project.selected.scene_bounds
        image_element = LaserNode(SVGImage(image=image))
        project.selected.append(image_element)
        image_element.element.transform.post_translate(xmin, ymin)
        project("elements", 0)

    return specific


def menu_reify(element):
    """
    Reify elements so that the translations apply direct to the object.

    :param element:
    :return:
    """

    def specific(event):
        for e in element.flat_elements(types=('path')):
            e.reify_matrix()
            project("elements", 0)

    return specific


def menu_reset(element):
    """
    Menu to reset transformations applied to elements.

    :param element:
    :return:
    """

    def specific(event):
        for e in element.flat_elements(types=('image', 'path', 'text')):
            e.element.transform.reset()
            project("elements", 0)

    return specific


def menu_rotate(element, value):
    """
    Menu to rotate an element.

    :param element:
    :param value:
    :return:
    """

    value *= tau

    def specific(event):
        center = element.center
        for e in element.flat_elements(types=('image', 'path', 'text')):
            e.transform.post_rotate(value, center[0], center[1])
        project("elements", 0)

    return specific


def menu_reload(element):
    """
    Menu to reload the element from the file on disk.

    :param element:
    :return:
    """

    filepath = element['filepath']

    def specific(event):
        for e in reversed(element):
            e.detach()
        MeerK40tApp.MeerK40t.load_file(filepath, group=element)

    return specific


def menu_remove(element, types=None):
    """
    Menu to remove an element from the scene.

    :param element:
    :return:
    """

    def delete_element(event):
        if types is None:
            try:
                element.parent.remove(element)
            except AttributeError:
                pass
            project.set_selected(None)
        else:
            for e in element.all_children_of_type(types=types):
                try:
                    e.parent.remove(e)
                except AttributeError:
                    pass
            project.set_selected(None)

    return delete_element


def menu_subpath(element):
    """
    Menu to break element into subpath.

    :param element:
    :return:
    """

    def specific(event):
        context = element
        for e in element.all_children_of_type(types=('path')):
            e.detach()
            p = abs(e.element)
            add = []
            for subpath in p.as_subpaths():
                subelement = LaserNode(Path(subpath))
                subelement.element.values.update(e.element.values)
                add.append(subelement)
            context.append_all(add)
        project("elements", 0)
        project.set_selected(None)

    return specific


def menu_execute(element):
    """
    Menu to launch Execute Job for the particular element.

    :param element:
    :return:
    """

    def open_jobinfo_window(event):
        window = project.open_window("JobInfo")
        window.set_elements([e for e in element.flat_elements(types=('image', 'path', 'text'), passes=True)])

    return open_jobinfo_window


def get_convex_hull(element):
    """
    Processing function for menu_hull(element) to return the hull points.

    :param element:
    :return:
    """
    pts = []
    for e in element.flat_elements(types=('image', 'path')):
        if isinstance(e.element, Path):
            epath = abs(e.element)
            pts += [q for q in epath.as_points()]
        elif isinstance(e.element, SVGImage):
            bounds = e.scene_bounds
            pts += [(bounds[0], bounds[1]), (bounds[0], bounds[3]), (bounds[2], bounds[1]), (bounds[2], bounds[3])]
    hull = [p for p in Point.convex_hull(pts)]
    if len(hull) == 0:
        return None
    return hull


def menu_hull(element):
    """
    Menu to return and add the convex hull of the element to the scene.

    :param element:
    :return:
    """

    def convex_hull(event):
        path = Path()
        pts = get_convex_hull(element)
        if pts is None:
            return
        path.move(*pts)
        path.closed()
        path.stroke = Color('black')
        context = element.parent
        context.append(LaserNode(path))
        project.set_selected(None)

    return convex_hull


def menu_reverse_order(element):
    """
    Menu to return and add the convex hull of the element to the scene.

    :param element:
    :return:
    """

    def specific(event):
        element.reverse()
        project("elements", 0)

    return specific


class MappedKey:
    """
    Mapped key class containing the key and the command.
    """

    def __init__(self, key, command):
        self.key = key
        self.command = command

    def __str__(self):
        return self.key


class MeerK40tGui(wx.App):
    """
    MeerK40t Gui Launch.
    """

    def OnInit(self):
        self.MeerK40t = MeerK40t(None, wx.ID_ANY, "")
        self.SetTopWindow(self.MeerK40t)
        self.MeerK40t.Show()
        return True


# end of class MeerK40tGui
def handleGUIException(exc_type, exc_value, exc_traceback):
    """
    Handler for errors. Save error to a file, and create dialog.

    :param exc_type:
    :param exc_value:
    :param exc_traceback:
    :return:
    """
    err_msg = ''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
    print(err_msg)
    try:
        import datetime
        filename = "MeerK40t-{date:%Y-%m-%d_%H_%M_%S}.txt".format(date=datetime.datetime.now())
        print(_("Saving Log: %s" % filename))
        with open(filename, "w") as file:
            file.write(_("MeerK40t crash log. Version: %s\n" % MEERK40T_VERSION))
            file.write(("Please report to: %s\n\n" % MEERK40T_ISSUES))
            file.write(err_msg)
            print(file)
    except:  # I already crashed once, if there's another here just ignore it.
        pass
    dlg = wx.MessageDialog(None, err_msg, _('Error encountered'), wx.OK | wx.ICON_ERROR)
    dlg.ShowModal()
    dlg.Destroy()


sys.excepthook = handleGUIException

if __name__ == "__main__":
    MeerK40tApp = MeerK40tGui(0)
    MeerK40tApp.MainLoop()
